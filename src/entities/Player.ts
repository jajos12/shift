// ============================================================
//  Player.ts — The player character
// ============================================================
//
//  GAME DEV CONCEPT: Extending Phaser.Physics.Arcade.Sprite
//  ----------------------------------------------------------
//  In Phaser, a Sprite is an image that can be positioned and animated.
//  An Arcade.Sprite is a Sprite with a PHYSICS BODY attached — it can
//  move with velocity, be affected by gravity, and collide with things.
//
//  By extending (inheriting from) Arcade.Sprite, our Player gets all
//  of that for free. We just add our own logic on top:
//  - Input handling (keyboard)
//  - Movement (run, jump, wall-slide, wall-jump)
//  - Dimension shifting
//  - Health and damage
//
//  IMPORTANT PATTERN: update()
//  Phaser calls GameScene.update() every frame (~60 times/second).
//  GameScene then calls player.update(). This is how we check input
//  and update movement EVERY frame. Without this, the player wouldn't
//  respond to key presses!
// ============================================================

import Phaser from 'phaser';
import { PLAYER, DIMENSIONS } from '../utils/Constants';
import type { DimensionManager } from '../systems/DimensionManager';
import type { TouchControls, TouchInputState } from '../systems/TouchControls';

// ============================================================
//  GAME DEV CONCEPT: State Machine for Animation
// ============================================================
//  The player can be in one of these states. Each state plays a
//  different animation (or in our case, changes the sprite tint).
//  We use this to keep track of what the player is doing.
//
//  Why a state machine? Because without one, you get spaghetti:
//    if (jumping && !falling && !wallSliding && ...) → nightmare
//
//  With a state machine:
//    currentState = 'jumping' → clean, readable, extensible
// ============================================================
type PlayerState = 'idle' | 'run' | 'jump' | 'fall' | 'wall-slide';

export class Player extends Phaser.Physics.Arcade.Sprite {
  // --- Input keys ---
  // Phaser provides a convenient CursorKeys object for arrow keys
  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
  private shiftKey!: Phaser.Input.Keyboard.Key;
  private wasdKeys!: {
    W: Phaser.Input.Keyboard.Key;
    A: Phaser.Input.Keyboard.Key;
    D: Phaser.Input.Keyboard.Key;
  };

  // --- State tracking ---
  private playerState: PlayerState = 'idle';
  private health: number = PLAYER.MAX_HEALTH;
  private isInvincible: boolean = false;
  private facingRight: boolean = true;

  // --- Coyote time & jump buffer ---
  // GAME DEV CONCEPT: Coyote Time
  // When you walk off a ledge, there's a ~100ms window where you
  // can still jump. Named after Wile E. Coyote who runs off cliffs
  // and hangs in the air for a moment. Without this, platformers
  // feel "unfair" — you SWEAR you pressed jump in time!
  private coyoteTimeCounter: number = 0;

  // GAME DEV CONCEPT: Jump Buffer
  // If you press jump ~100ms BEFORE landing, the jump still triggers
  // the moment you touch ground. Without this, you'd need frame-perfect
  // timing, which feels terrible.
  private jumpBufferCounter: number = 0;

  // --- Shift key tracking ---
  // We only want to shift ONCE per key press, not every frame
  // the key is held down. JustDown tracks this.
  private shiftJustPressed: boolean = false;
  private shiftWasDown: boolean = false;

  // --- Reference to the DimensionManager ---
  private dimensionManager!: DimensionManager;

  // --- Touch controls (optional, only present on mobile) ---
  private touchControls?: TouchControls;

  // ========================================================
  //  Constructor
  // ========================================================
  constructor(scene: Phaser.Scene, x: number, y: number) {
    // Call the parent constructor:
    //   scene = which scene this sprite belongs to
    //   x, y = starting position in PIXELS
    //   'player' = the texture key (generated by TextureGenerator)
    super(scene, x, y, 'player-idle-0');

    // --- Add to scene ---
    // These two lines are ALWAYS needed for a physics sprite:
    scene.add.existing(this);       // Registers for rendering (drawing)
    scene.physics.add.existing(this); // Creates the physics body

    // --- Configure physics body ---
    const body = this.body as Phaser.Physics.Arcade.Body;

    // Make the hitbox SMALLER than the sprite
    // Why? Because a too-big hitbox feels unfair — you get hit by things
    // that visually didn't touch you. A smaller hitbox = forgiving gameplay.
    body.setSize(PLAYER.BODY_WIDTH, PLAYER.BODY_HEIGHT);
    body.setOffset(PLAYER.BODY_OFFSET_X, PLAYER.BODY_OFFSET_Y);

    // Don't let the player fall out of the world
    body.setCollideWorldBounds(true);

    // Higher max velocity so wall-jump feels snappy
    body.setMaxVelocityY(600);

    // --- Set up keyboard input ---
    if (scene.input.keyboard) {
      this.cursors = scene.input.keyboard.createCursorKeys();
      this.shiftKey = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
      this.wasdKeys = {
        W: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
        A: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
        D: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
      };
    }

    // Set render depth so player draws above tiles
    this.setDepth(10);
  }

  // ========================================================
  //  setDimensionManager — Called by GameScene after creation
  // ========================================================
  setDimensionManager(dm: DimensionManager): void {
    this.dimensionManager = dm;
  }

  // ========================================================
  //  setTouchControls — Called by GameScene on mobile devices
  // ========================================================
  setTouchControls(tc: TouchControls): void {
    this.touchControls = tc;
  }

  // ========================================================
  //  update() — Runs EVERY FRAME (~60fps)
  // ========================================================
  //
  //  This is the player's "brain". Every 16.6ms (at 60fps):
  //    1. Read keyboard input
  //    2. Decide what to do (move, jump, shift)
  //    3. Apply velocity changes
  //    4. Update animation state
  //
  //  IMPORTANT: We use `delta` (milliseconds since last frame)
  //  for timers. This makes the game frame-rate independent —
  //  it plays the same at 30fps and 144fps.
  //
  update(_time: number, delta: number): void {
    const body = this.body as Phaser.Physics.Arcade.Body;
    if (!body) return;

    const onGround = body.blocked.down;
    const touchingWallLeft = body.blocked.left;
    const touchingWallRight = body.blocked.right;
    const touchingWall = touchingWallLeft || touchingWallRight;

    // ---- Input reading ----
    // Support BOTH arrow keys AND WASD AND touch controls
    const touch: TouchInputState | undefined = this.touchControls?.getState();
    const leftDown = this.cursors.left?.isDown || this.wasdKeys.A.isDown || (touch?.leftDown ?? false);
    const rightDown = this.cursors.right?.isDown || this.wasdKeys.D.isDown || (touch?.rightDown ?? false);
    // jumpDown is checked inline below via JustDown for jump buffer

    // ---- Coyote time ----
    // If we're on the ground, reset the counter (we can jump)
    // If we just left the ground, count down the grace period
    if (onGround) {
      this.coyoteTimeCounter = PLAYER.COYOTE_TIME_MS;
    } else {
      this.coyoteTimeCounter -= delta;
    }

    // ---- Jump buffer ----
    // If jump is pressed, start the buffer timer
    const keyboardJump = Phaser.Input.Keyboard.JustDown(this.cursors.up!) ||
        Phaser.Input.Keyboard.JustDown(this.wasdKeys.W) ||
        Phaser.Input.Keyboard.JustDown(this.cursors.space!);
    if (keyboardJump || (touch?.jumpJustPressed ?? false)) {
      this.jumpBufferCounter = PLAYER.JUMP_BUFFER_MS;
    } else {
      this.jumpBufferCounter -= delta;
    }

    // ==========================
    //  HORIZONTAL MOVEMENT
    // ==========================
    if (leftDown) {
      body.setVelocityX(-PLAYER.SPEED);
      this.facingRight = false;
      this.setFlipX(true); // Mirror the sprite
    } else if (rightDown) {
      body.setVelocityX(PLAYER.SPEED);
      this.facingRight = true;
      this.setFlipX(false);
    } else {
      // No input → stop immediately (no sliding)
      // In a platformer, instant stop feels responsive.
      // For a physics sim, you'd use friction instead.
      body.setVelocityX(0);
    }

    // ==========================
    //  JUMPING
    // ==========================
    // Can jump if:
    //   - Within coyote time (recently on ground) AND jump buffer active
    //   - OR touching a wall (wall-jump)
    const canNormalJump = this.coyoteTimeCounter > 0 && this.jumpBufferCounter > 0;

    if (canNormalJump) {
      body.setVelocityY(PLAYER.JUMP_VELOCITY);
      this.coyoteTimeCounter = 0;   // Consume coyote time
      this.jumpBufferCounter = 0;   // Consume jump buffer
    }

    // ==========================
    //  WALL SLIDE
    // ==========================
    //  GAME DEV CONCEPT: Wall Sliding
    //  When pressing into a wall while airborne, the player
    //  slides down slowly instead of falling at full speed.
    //  This creates a window for wall-jumping.
    if (touchingWall && !onGround && body.velocity.y > 0) {
      // Pressing toward the wall?
      const pressingIntoWall =
        (touchingWallLeft && leftDown) ||
        (touchingWallRight && rightDown);

      if (pressingIntoWall) {
        body.setVelocityY(PLAYER.WALL_SLIDE_SPEED);
        this.playerState = 'wall-slide';

        // Wall jump: press jump while wall-sliding
        if (this.jumpBufferCounter > 0) {
          // Launch AWAY from the wall
          const pushDir = touchingWallLeft ? 1 : -1;
          body.setVelocityX(PLAYER.WALL_JUMP_VELOCITY_X * pushDir);
          body.setVelocityY(PLAYER.WALL_JUMP_VELOCITY_Y);
          this.jumpBufferCounter = 0;
        }
      }
    }

    // ==========================
    //  DIMENSION SHIFT
    // ==========================
    //  We track "just pressed" manually because Phaser's JustDown
    //  can be unreliable across scene boundaries.
    const shiftDown = this.shiftKey.isDown;
    this.shiftJustPressed = (shiftDown && !this.shiftWasDown) || (touch?.shiftJustPressed ?? false);
    this.shiftWasDown = shiftDown;

    if (this.shiftJustPressed && this.dimensionManager) {
      this.dimensionManager.shift();
    }

    // ==========================
    //  ANIMATION STATE
    // ==========================
    this.updateState(onGround, body.velocity);

    // ==========================
    //  INVINCIBILITY FLASH
    // ==========================
    // When invincible, rapidly toggle visibility (flashing effect)
    if (this.isInvincible) {
      this.setAlpha(Math.sin(Date.now() * 0.02) > 0 ? 1 : 0.3);
    } else {
      this.setAlpha(1);
    }
  }

  // ========================================================
  //  updateState — Determine animation state from physics
  // ========================================================
  private updateState(onGround: boolean, velocity: Phaser.Math.Vector2): void {
    let newState: PlayerState;

    if (this.playerState === 'wall-slide') {
      // Wall-slide state is set above, only exit when not sliding
      const body = this.body as Phaser.Physics.Arcade.Body;
      if (onGround || (!body.blocked.left && !body.blocked.right)) {
        newState = onGround ? 'idle' : 'fall';
      } else {
        return; // Stay in wall-slide
      }
    } else if (onGround) {
      newState = Math.abs(velocity.x) > 10 ? 'run' : 'idle';
    } else {
      newState = velocity.y < 0 ? 'jump' : 'fall';
    }

    if (newState !== this.playerState) {
      this.playerState = newState;
      this.applyStateVisuals();
    }
  }

  // ========================================================
  //  applyStateVisuals — Visual feedback for current state
  // ========================================================
  //  Since we're using placeholder sprites (no real animations),
  //  we change the tint color to indicate state. When you add
  //  real sprite sheets, you'd replace this with animation calls.
  //
  private applyStateVisuals(): void {
    // Clear any tint from previous state
    this.clearTint();

    switch (this.playerState) {
      case 'idle':
        this.play('player-idle', true);
        break;
      case 'run':
        this.play('player-run', true);
        break;
      case 'jump':
        this.play('player-jump', true);
        break;
      case 'fall':
        this.play('player-fall', true);
        break;
      case 'wall-slide':
        // No wall-slide sprite yet — use fall frame + tint
        this.play('player-fall', true);
        this.setTint(0xffaa44);
        break;
    }
  }

  // ========================================================
  //  takeDamage — Called when player hits an enemy/hazard
  // ========================================================
  takeDamage(amount: number = 1): void {
    if (this.isInvincible) return;

    this.health -= amount;

    // Knockback — push player away from danger
    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setVelocityY(PLAYER.KNOCKBACK_Y);
    body.setVelocityX(this.facingRight ? -PLAYER.KNOCKBACK_X : PLAYER.KNOCKBACK_X);

    // Start invincibility frames
    this.isInvincible = true;
    this.scene.time.delayedCall(PLAYER.INVINCIBILITY_MS, () => {
      this.isInvincible = false;
      this.setAlpha(1);
    });

    // Camera shake for impact
    this.scene.cameras.main.shake(200, 0.01);

    // Check for death
    if (this.health <= 0) {
      this.die();
    }
  }

  // ========================================================
  //  die — Player ran out of health
  // ========================================================
  private die(): void {
    // Emit an event that GameScene listens for
    // GAME DEV CONCEPT: Events
    // Instead of the player directly calling GameScene methods,
    // we emit an event. This is "loose coupling" — the player
    // doesn't need to know about GameScene's internals.
    this.scene.events.emit('player-died');
  }

  // ========================================================
  //  Getters
  // ========================================================
  getHealth(): number { return this.health; }
  getMaxHealth(): number { return PLAYER.MAX_HEALTH; }
  getPlayerState(): PlayerState { return this.playerState; }

  resetHealth(): void {
    this.health = PLAYER.MAX_HEALTH;
    this.isInvincible = false;
    this.setAlpha(1);
  }

  getCurrentDimension(): string {
    return this.dimensionManager?.getCurrent() ?? DIMENSIONS.LUMINA;
  }
}
